
/**
 * \file CanBasicDemo.c
 * \brief Demo CanBasicDemo
 *
 * \version iLLD_Demos_1_0_1_15_0
 * \copyright Copyright (c) 2014 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include <stdio.h>
#include "CanBasicDemo.h"
#include <Cpu/Irq/IfxCpu_Irq.h>
#include "IfxCpu.h"
/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
#define IFX_INTTOS_CAN_TXRX 0
/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/

App_CanBasic g_CanBasic;

/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
static volatile uint32 numTxmsgs[IFXCAN_NUM_MODULES];
static volatile uint32 numRxmsgs[IFXCAN_NUM_MODULES];
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/

/** \addtogroup IfxLld_Demo_CanDemo_SrcDoc_Main_Interrupt
 * \{ */

/** \} */

/** \brief Handle Tx interrupt on CAN node1 module 0.
 *
 * \isrProvider \ref IFX_INTTOS_CAN_TXRX
 * \isrPriority \ref ISR_PRIORITY_CAN1_TX
 *
 */
IFX_INTERRUPT(Tx_Interrput1_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN1_TX)
{
	Ifx_CAN   *canSfr = &MODULE_CAN1;

	if(CAN1_IR0.B.TC == 1)
	{
		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
		IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_transmissionCompleted);
		numTxmsgs[1]++;
	}
}

/** \brief Handle Rx interrupt on CAN node0 module 0.
 *
 * \isrProvider \ref IFX_INTTOS_CAN_TXRX
 * \isrPriority \ref ISR_PRIORITY_CAN0_RX
 *
 */
IFX_INTERRUPT(Rx_Interrput0_ISR, IFX_INTTOS_CAN_TXRX, ISR_PRIORITY_CAN0_RX)
{
	Ifx_CAN   *canSfr =  &MODULE_CAN0;

	if(CAN0_IR0.B.DRX == 1)
	{
		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
		IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);
		numRxmsgs[0]++;
	}

}




/** \brief Demo init API
 *
 * This function is called from main during initialization phase
 */
void CanBasicDemo_init(void)
{
	IfxScuCcu_Config IfxScuCcuConfig;

	/* interrupt groups configuration */
	volatile Ifx_SRC_SRCR *srcPointer;
    /* disable interrupts */
    boolean              interruptState = IfxCpu_disableInterrupts();

    /* Default clock initialisation */
    IfxScuCcu_initConfig(&IfxScuCcuConfig);
    IfxScuCcu_init(&IfxScuCcuConfig);

	/* CAN0 initilaisation */
	{
		/* create module configuration */
		IfxCan_Can_Config canConfig;
		IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN0);

		/* initialize module */
		IfxCan_Can_initModule(&g_CanBasic.drivers.can[0], &canConfig);
	}

	/* CAN1 initilaisation */
	{
		 /*create module configuration*/
		IfxCan_Can_Config canConfig;
		IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN1);

		 /*initialize module*/
		IfxCan_Can_initModule(&g_CanBasic.drivers.can[1], &canConfig);
	}

     /*create node configuration*/

     /*CAN 0 Node0 as receive node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[0]);

        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_receive;

        nodeConfig.messageRAM.standardFilterListStartAddress = 0x100;
        nodeConfig.messageRAM.rxBuffersStartAddress          = 0x200;
        nodeConfig.messageRAM.baseAddress                    = (uint32)&MODULE_CAN0;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD00B_P20_7_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD00_P20_8_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

        /* For interrupt configuration user needs to configure the priority and select one of the 16 interrupt lines*/
        nodeConfig.interruptConfig.reint.priority = ISR_PRIORITY_CAN0_RX ;
        nodeConfig.interruptConfig.reint.interruptLine =  IfxCan_InterruptLine_14;
        nodeConfig.interruptConfig.reint.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[0], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[0].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);
        /* Enable interrupts in CAN */
		IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);
        IfxCan_Node_disableConfigurationChange(nodeSfr);
        printf(" Rx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[0].node);
    }

    /* CAN 1 Node 0 as transmit node*/
    {
        IfxCan_Can_NodeConfig nodeConfig;
        IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanBasic.drivers.can[1]);

        nodeConfig.nodeId = IfxCan_NodeId_0;
        nodeConfig.frame.type = IfxCan_FrameType_transmit;
        nodeConfig.txConfig.dedicatedTxBuffersNumber = 2;

        nodeConfig.messageRAM.txBuffersStartAddress = 0x400;
        nodeConfig.messageRAM.baseAddress           = (uint32)&MODULE_CAN1;

        IfxCan_Can_Pins pins;
        pins.rxPin = &IfxCan_RXD10C_P23_0_IN;
        pins.rxPinMode = IfxPort_InputMode_pullUp;
        pins.txPin = &IfxCan_TXD10_P23_1_OUT;
        pins.txPinMode = IfxPort_OutputMode_pushPull;
        pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
        nodeConfig.pins = &pins;

         /*Enabling interrupts*/
        nodeConfig.interruptConfig.traco.priority  = ISR_PRIORITY_CAN1_TX ;
        nodeConfig.interruptConfig.traco.interruptLine =  IfxCan_InterruptLine_15;
        nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

         /*initialize module*/
        IfxCan_Can_initNode(&g_CanBasic.drivers.canNode[1], &nodeConfig);

        Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanBasic.drivers.canNode[1].can, nodeConfig.nodeId);

        IfxCan_Node_enableConfigurationChange(nodeSfr);

        /* Enable interrupts in CAN */
	IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCompleted);

	/* disable configuration change CCCR.CCE = 0 */
	IfxCan_Node_disableConfigurationChange(nodeSfr);

        printf(" Tx Node Base Address  = %x\n",(unsigned int)g_CanBasic.drivers.canNode[1].node);
    }

    /* set filters */

    {
        /* Initialise the filter structure */
        IfxCan_Filter filter;

        /* Set a range filter to accept the CAN message with Ids 0x00- 0x7ff*/

        /* set filter0 for rxBuffer 0 */
        filter.number = 0;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x00;
        filter.rxBufferOffset = IfxCan_RxBufferId_0;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);

        /* set filter0 for rxBuffer 1 */
        filter.number = 1;
        filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
        filter.id1 = 0x7ff;
        filter.rxBufferOffset = IfxCan_RxBufferId_1;

        IfxCan_Can_setStandardFilter(&g_CanBasic.drivers.canNode[0], &filter);
    }

    /* enable interrupts again */
    IfxCpu_restoreInterrupts(interruptState);

    printf("CAN is initialised\n");
}


/** \brief Demo run API
 *
 * This function is called from main, background loop
 */
void CanBasicDemo_run(void)
{
    int i, errors = 0;
	uint32 txData[2];
	uint32 rxData[2];


	printf("Send data\n");

	/* data that needs to be transmitted */
	txData[0] = 0xC0C0C01A;
	txData[1] = 0xBA5EBA11;

	/* Initialise the message strcture */
	IfxCan_Message txMsg;
	IfxCan_Can_initMessage(&txMsg);

	txMsg.messageId = 0x00;
	txMsg.bufferNumber = 0;

	 /*Transmit Data*/
	while (IfxCan_Can_sendMessage(&g_CanBasic.drivers.canNode[1], &txMsg, txData) == IfxCan_Status_notSentBusy);

	printf("Receive data\n");

	 /* Initialise Rx buffer data */
	rxData[0] = 0xdeadbeef;
	rxData[1] = 0xdeadbeef;

	 /*Initialise the message structure with dummy values, will be replaced by the received values*/
	IfxCan_Message rxMsg;
	IfxCan_Can_initMessage(&rxMsg);

	 /*specify the rx buffer number where the data will be received*/
	rxMsg.bufferNumber = 0;


	 while ((IfxCan_Can_isNewDataReceived(&g_CanBasic.drivers.canNode[0], (IfxCan_RxBufferId)rxMsg.bufferNumber)) == 0)
	 { }

	 /*read message*/
	IfxCan_Can_readMessage(&g_CanBasic.drivers.canNode[0], &rxMsg, rxData);
	printf("ID : %d   Frame Mode : %d   data Length code : %d\n", (int)rxMsg.messageId, rxMsg.frameMode, rxMsg.dataLengthCode);

    /* check received data */
    for (i = 0; i < 2; ++i)
    {
        if (rxData[i] != txData[i])
        {
            ++errors;
        }
    }

    if (errors)
    {
        printf("ERROR: received data doesn't match with expected data (%d mismatches)\n", errors);
    }
    else
    {
        printf("OK: received data matches with expected data\n");
    }

    printf("Can Basic data transfers are finished\n");
}

