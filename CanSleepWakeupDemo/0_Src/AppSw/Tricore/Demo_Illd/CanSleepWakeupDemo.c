
/**
 * \file CanSleepWakeupDemo.c
 * \brief Demo CanSleepWakeupDemo
 *
 * \version iLLD_Demos_1_0_1_15_0
 * \copyright Copyright (c) 2019 Infineon Technologies AG. All rights reserved.
 *
 *
 *                                 IMPORTANT NOTICE
 *
 * Use of this file is subject to the terms of use agreed between (i) you or
 * the company in which ordinary course of business you are acting and (ii)
 * Infineon Technologies AG or its licensees. If and as long as no such terms
 * of use are agreed, use of this file is subject to following:
 *
 * Boost Software License - Version 1.0 - August 17th, 2003
 *
 * Permission is hereby granted, free of charge, to any person or organization
 * obtaining a copy of the software and accompanying documentation covered by
 * this license (the "Software") to use, reproduce, display, distribute,
 * execute, and transmit the Software, and to prepare derivative works of the
 * Software, and to permit third-parties to whom the Software is furnished to
 * do so, all subject to the following:
 *
 * The copyright notices in the Software and this entire statement, including
 * the above license grant, this restriction and the following disclaimer, must
 * be included in all copies of the Software, in whole or in part, and all
 * derivative works of the Software, unless such copies or derivative works are
 * solely in the form of machine-executable object code generated by a source
 * language processor.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 * SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 * FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 * DEALINGS IN THE SOFTWARE.
 */

/******************************************************************************/
/*----------------------------------Includes----------------------------------*/
/******************************************************************************/

#include <stdio.h>
#include "CanSleepWakeupDemo.h"
#include <Cpu/Irq/IfxCpu_Irq.h>
#include <Pms/Std/IfxPmsPm.h>
#include <Stm/Std/IfxStm.h>
#include <Scu/Std/IfxScuCcu.h>
#include "IfxCpu.h"
/******************************************************************************/
/*-----------------------------------Macros-----------------------------------*/
/******************************************************************************/
#define STD_FILTER_LIST_START_ADD 	(0x100)
#define IFX_CAN0_RX_BUF_START_ADD 	(0x200)
#define IFX_CAN1_TX_BUF_START_ADD	(0x400)
/******************************************************************************/
/*--------------------------------Enumerations--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*-----------------------------Data Structures--------------------------------*/
/******************************************************************************/

/******************************************************************************/
/*------------------------------Global variables------------------------------*/
/******************************************************************************/

App_CanSleepWakeup g_CanSleepWakeup;
static volatile uint8  wakeupIrqReceived;
/******************************************************************************/
/*-------------------------Function Prototypes--------------------------------*/
/******************************************************************************/
int issueSleep(void);
/******************************************************************************/
/*------------------------Private Variables/Constants-------------------------*/
/******************************************************************************/
static volatile uint8 numTxmsgs[3];
static volatile uint8 numRxmsgs[3];
/******************************************************************************/
/*-------------------------Function Implementations---------------------------*/
/******************************************************************************/



IFX_INTERRUPT(stm0Sr0ISR, 0, IFX_ISR_PRIORITY_STM)
{
	wakeupIrqReceived++;
}

/** \brief Handle Tx interrupt on CAN1 Node0.
 *
 * \isrProvider \ref ISR_PROVIDER_CAN1_TX
 * \isrPriority \ref ISR_PRIORITY_CAN1_TX
 *
 */
IFX_INTERRUPT(Can1Tx, 0, IFX_INTPRIO_CAN1_TX)
{
	Ifx_CAN   *canSfr = &MODULE_CAN1;

	if(CAN1_IR0.B.TC == 1)
	{
		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
		IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_transmissionCompleted);
		numTxmsgs[1]++;
	}
}

/** \brief Handle Rx interrupt on CAN0 Node0.
 *
 * \isrProvider \ref ISR_PROVIDER_CAN0_RX
 * \isrPriority \ref ISR_PRIORITY_CAN0_RX
 *
 */
IFX_INTERRUPT(Can0Rx, 0, IFX_INTPRIO_CAN0_RX)
{
	Ifx_CAN   *canSfr =  &MODULE_CAN0;
	if(CAN0_IR0.B.DRX == 1)
	{
		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(canSfr,(IfxCan_NodeId)0);
		IfxCan_Node_clearInterruptFlag(nodeSfr,IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);
		numRxmsgs[0]++;
	}

}



/** \brief Demo init API
 *
 * This function is called from main during initialization phase
 */
void CanSleepWakeupDemo_init(void)
{
	IfxScuCcu_Config IfxScuCcuConfig;

	/* interrupt groups configuration */
	/* disable interrupts */
	boolean interruptState = IfxCpu_disableInterrupts();

	/* Default clock initialisation */
	IfxScuCcu_initConfig(&IfxScuCcuConfig);
	IfxScuCcu_init(&IfxScuCcuConfig);

	/* Put MCAN in slow clock mode */
	IfxScuCcu_setMcanFrequency(20000000);

	/* CAN0 initilaisation */
	{
		/* create module configuration */
		IfxCan_Can_Config canConfig;
		IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN0);

		/* initialize module */
		IfxCan_Can_initModule(&g_CanSleepWakeup.drivers.can[0], &canConfig);
		IfxCan_setSleepMode(g_CanSleepWakeup.drivers.can[0].can,IfxCan_SleepMode_enable);

	}

	/* CAN1 initilaisation */
	{
		/*create module configuration*/
		IfxCan_Can_Config canConfig;
		IfxCan_Can_initModuleConfig(&canConfig, &MODULE_CAN1);

		/*initialize module*/
		IfxCan_Can_initModule(&g_CanSleepWakeup.drivers.can[1], &canConfig);

	}

	/*create node configuration*/

	/*CAN 0 Node0 as receive node*/
	{
		IfxCan_Can_NodeConfig nodeConfig;
		IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanSleepWakeup.drivers.can[0]);

		nodeConfig.nodeId = IfxCan_NodeId_0;
		nodeConfig.frame.type = IfxCan_FrameType_receive;

		nodeConfig.messageRAM.standardFilterListStartAddress = STD_FILTER_LIST_START_ADD;
		nodeConfig.messageRAM.rxBuffersStartAddress          = IFX_CAN0_RX_BUF_START_ADD;
		nodeConfig.messageRAM.baseAddress                    = (uint32)&MODULE_CAN0;

		IfxCan_Can_Pins pins;
		pins.rxPin = &IfxCan_RXD00B_P20_7_IN;
		pins.rxPinMode = IfxPort_InputMode_pullUp;
		pins.txPin = &IfxCan_TXD00_P20_8_OUT;
		pins.txPinMode = IfxPort_OutputMode_pushPull;
		pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
		nodeConfig.pins = &pins;

		nodeConfig.interruptConfig.reint.priority = IFX_INTPRIO_CAN0_RX ;
		nodeConfig.interruptConfig.reint.interruptLine =  IfxCan_InterruptLine_14;
		nodeConfig.interruptConfig.reint.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

		IfxCan_Can_initNode(&g_CanSleepWakeup.drivers.canNode[0], &nodeConfig);

		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanSleepWakeup.drivers.canNode[0].can, nodeConfig.nodeId);

		IfxCan_Node_enableConfigurationChange(nodeSfr);
		IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_messageStoredToDedicatedRxBuffer);
		IfxCan_Node_disableConfigurationChange(nodeSfr);
		printf(" Rx Node Base Address  = %x\n",(unsigned int)g_CanSleepWakeup.drivers.canNode[0].node);
	}

	/* CAN 1 Node 0 as transmit node*/
	{
		IfxCan_Can_NodeConfig nodeConfig;
		IfxCan_Can_initNodeConfig(&nodeConfig, &g_CanSleepWakeup.drivers.can[1]);

		nodeConfig.nodeId = IfxCan_NodeId_0;
		/* Set CAN in transmit mode */
		nodeConfig.frame.type = IfxCan_FrameType_transmit;
		/* CAN transmission is over buffer no: 2*/
		nodeConfig.txConfig.dedicatedTxBuffersNumber = 2;
		nodeConfig.messageRAM.txBuffersStartAddress = IFX_CAN1_TX_BUF_START_ADD;
		nodeConfig.messageRAM.baseAddress           = (uint32)&MODULE_CAN1;
        /* Pin configuration */
		IfxCan_Can_Pins pins;
		pins.rxPin = &IfxCan_RXD10C_P23_0_IN;
		pins.rxPinMode = IfxPort_InputMode_pullUp;
		pins.txPin = &IfxCan_TXD10_P23_1_OUT;
		pins.txPinMode = IfxPort_OutputMode_pushPull;
		pins.padDriver = IfxPort_PadDriver_cmosAutomotiveSpeed2;
		nodeConfig.pins = &pins;

		/*Enabling interrupts*/
		nodeConfig.interruptConfig.traco.priority  = IFX_INTPRIO_CAN1_TX ;
		nodeConfig.interruptConfig.traco.interruptLine =  IfxCan_InterruptLine_15;
		nodeConfig.interruptConfig.traco.typeOfService = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());

		/*initialize module*/
		IfxCan_Can_initNode(&g_CanSleepWakeup.drivers.canNode[1], &nodeConfig);

		Ifx_CAN_N *nodeSfr = IfxCan_getNodePointer(g_CanSleepWakeup.drivers.canNode[1].can, nodeConfig.nodeId);

		IfxCan_Node_enableConfigurationChange(nodeSfr);

		IfxCan_Node_enableInterrupt(nodeSfr, IfxCan_Interrupt_transmissionCompleted);

		/* disable configuration change CCCR.CCE = 0 */
		IfxCan_Node_disableConfigurationChange(nodeSfr);

		printf(" Tx Node Base Address  = %x\n",(unsigned int)g_CanSleepWakeup.drivers.canNode[1].node);
	}

	/* Filter configuration */
	{
		/* Initialise the filter structure */
		IfxCan_Filter filter;

		/* set filter0 for rxBuffer 0 */
		filter.number = 0;
		filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
		filter.id1 = 0x00;
		filter.rxBufferOffset = IfxCan_RxBufferId_0;

		IfxCan_Can_setStandardFilter(&g_CanSleepWakeup.drivers.canNode[0], &filter);

		/* set filter1 for rxBuffer 1 */
		filter.number = 1;
		filter.elementConfiguration = IfxCan_FilterElementConfiguration_storeInRxBuffer;
		filter.id1 = 0x7ff;
		filter.rxBufferOffset = IfxCan_RxBufferId_1;

		IfxCan_Can_setStandardFilter(&g_CanSleepWakeup.drivers.canNode[0], &filter);
	}

	/* enable interrupts again */
	IfxCpu_restoreInterrupts(interruptState);

	printf("CAN is initialised\n");
}


/** \brief Demo run API
 *
 * This function is called from main, background loop
 */
void CanSleepWakeupDemo_run(void)
{
	int i, errors = 0;
	IfxCan_Message txMsg;
	uint32 txData[2];
	uint32 rxData[2];


	printf("Send data\n");

	/* Default value of data to be transmitted */
	txData[0] = 0xC0C0C01A;
	txData[1] = 0xBA5EBA11;


	/* Switching the CPU0 in low power mode */
	IfxScuCcu_switchToLowPowerMode(IfxScuCcu_LowPowerDivRatio_divBy60);

	/* Initialise the message structure */
	IfxCan_Can_initMessage(&txMsg);

	txMsg.messageId = 0x00;
	txMsg.bufferNumber = 1;

	wakeupIrqReceived = 0;

	/* waiting for wakeup via SCU interrupt */
	printf("Sleep is issued...");
	issueSleep();

	while(wakeupIrqReceived == 0);

	/* Transmit Data */
	while (IfxCan_Can_sendMessage(&g_CanSleepWakeup.drivers.canNode[1], &txMsg, txData) == IfxCan_Status_notSentBusy);

	printf("Receive data\n");

	/* Initialise default values */
	rxData[0] = 0xdeadbeef;
	rxData[1] = 0xdeadbeef;

	/* Initialise the message structure with dummy values, will be replaced by the received values */
	IfxCan_Message rxMsg;
	IfxCan_Can_initMessage(&rxMsg);

	/* specify the rx buffer number where the data will be received */
	rxMsg.bufferNumber = 0;

	wakeupIrqReceived = 0;

	/* Wait till the  new data recieved in CAN */
	while ((IfxCan_Can_isNewDataReceived(&g_CanSleepWakeup.drivers.canNode[0], (IfxCan_RxBufferId)rxMsg.bufferNumber)) == 0)
	{ }

	/* read message */
	IfxCan_Can_readMessage(&g_CanSleepWakeup.drivers.canNode[0], &rxMsg, rxData);
	printf("ID : %d   Frame Mode : %d   data Length code : %d\n", (uint8)rxMsg.messageId, rxMsg.frameMode, rxMsg.dataLengthCode);

	/* check received data */
	for (i = 0; i < 2; ++i)
	{
		if (rxData[i] != txData[i])
		{
			++errors;
		}
	}

	if (errors)
	{
		printf("ERROR: received data doesn't match with expected data (%d mismatches)\n", errors);
	}
	else
	{
		printf("OK: received data matches with expected data\n");
	}

	printf("Can Basic data transfers are finished\n");
}

/** \brief Issue sleep to the core
 *
 *  Core enters sleep state
 */
int issueSleep(void)
{
	int result=0;

    Ifx_STM             *stmSfr;            /**< \brief Pointer to Stm register base */
    IfxStm_CompareConfig stmConfig;         /**< \brief Stm Configuration structure */
    stmSfr = &MODULE_STM0;
    IfxStm_initCompareConfig(&stmConfig);
    stmConfig.triggerPriority = IFX_ISR_PRIORITY_STM;
    stmConfig.typeOfService   = IfxCpu_Irq_getTos(IfxCpu_getCoreIndex());
    /* configure STM for wakeup interrupt after 1000 cycles */
    stmConfig.ticks = 1000;
    /* Do not enable sleep mode in STM0*/
	IfxStm_setSleepMode(stmSfr,IfxStm_SleepMode_disable);
	IfxStm_initCompare(stmSfr, &stmConfig);

	/* only a single CPU should request sleep */
	IfxPmsPm_setMasterCpu(IfxCpu_getCoreIndex());
	result |= IfxPmsPm_setCoreMode(IfxCpu_getCoreIndex(), IfxCpu_CoreMode_run);

	return result;
}

